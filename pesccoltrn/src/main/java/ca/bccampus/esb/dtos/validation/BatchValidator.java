package ca.bccampus.esb.dtos.validation;

import java.io.ByteArrayInputStream;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import org.w3c.dom.Document;


public class BatchValidator {
	
	// the schema against which we validate
	private String batchSchemaLocation = null;
	private Schema batchSchema = null;
	
	/**
	 * Load into a DOM the String source.
	 * Note: To decipher the errors:
	 *  catch (SAXParseException spe) {
	    	// Error generated by the parser
	    	System.out.println ("parse error: " + "line(" + spe.getLineNumber() + ") uri(" + spe.getSystemId() + ") error(" + spe.getMessage() + ")");
	    } 
	    catch (SAXException sxe) {
	    	// Error generated during parsing
	    	Exception  x = sxe;
	    	if (sxe.getException() != null) x = sxe.getException();
	    	System.out.println ("sax error: " + x.getMessage());
	    }
	    catch (ParserConfigurationException pce) {
	    	// Parser with specified options can't be built
	    	System.out.println ("invalid parser: " + pce.getMessage());
	    }
	    catch (IOException ioe) {
	    	// I/O error
	    	System.out.println ("io error: " + ioe.getMessage());
	    }
	 * 
	 * @param source string
	 * @return
	 * @throws Exception
	 */
	public Document loadDom (String source) throws Exception {
		
		// returned document
		Document document = null;
		
		// Document builder factory
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		
		// Document builder
		DocumentBuilder builder = factory.newDocumentBuilder();
		
		// InputStream
		StringBuffer sBuffer = new StringBuffer(source);
		ByteArrayInputStream input = new ByteArrayInputStream(sBuffer.toString().getBytes("UTF-8"));

		// build the document
		document = builder.parse(input);
		return document;
	}
	
	/**
	 * validate the XML document contained in source String with wired configuration schema
	 * @param source
	 * @return
	 * @throws Exception
	 */
	public void validate (String source) throws Exception {

		// load the schema if not already done (gets loaded only the first time and reused after that)
		loadSchema();
		
		// make a DOM out of the source
		Document dom = loadDom (source);
		
		// create the validator for our DOM
		Validator validator = batchSchema.newValidator();

		// validate
		try {
			validator.validate(new DOMSource (dom));
		}
		catch (Exception e) {
			Exception ne = new Exception (e);
			throw ne;
		}
	}
	
	// load the schema into DOM
	private void loadSchema() throws Exception {
		if (batchSchemaLocation == null) {
			Exception e = new Exception("No schema Location configured");
			throw e;
		}
		else if (batchSchema == null) {
			// define the type of schema - we use W3C:
		    String schemaLang = "http://www.w3.org/2001/XMLSchema";

		    // get validation driver:
		    SchemaFactory factory = SchemaFactory.newInstance(schemaLang);

		    // create schema by reading it from an XSD file:
		    batchSchema = factory.newSchema(new StreamSource(batchSchemaLocation));
		}
	}
	
	// for spring wiring
	public void setBatchSchemaLocation (String schemaLocation) {
		batchSchemaLocation = schemaLocation;
	}
}
